<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Concurrency Patterns in Go &mdash; Paolo Mascia</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="article.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
</head>
<body>

    <nav class="navbar scrolled">
        <div class="container">
            <a href="index.html" class="nav-logo">
                <span class="logo-accent">&gt;</span> paolo.mascia
            </a>
            <div class="nav-links">
                <a href="index.html#about">About</a>
                <a href="index.html#projects">Projects</a>
                <a href="ai-tech-insights.html">AI Tech Insights</a>
                <a href="cybersecurity-tech-insights.html">Cybersecurity</a>
                <a href="golang-tech-insights.html">Go</a>
                <a href="index.html#contact">Contact</a>
            </div>
        </div>
    </nav>

    <article class="article">
        <div class="container">
            <div class="article-layout">
                <div class="article-main">
                    <header class="article-header">
                        <a href="golang-tech-insights.html" class="back-link">&larr; Back to Go Tech Insights</a>
                        <div class="post-meta">
                            <span class="post-date">October 2025</span>
                            <span class="post-reading">12 min read</span>
                        </div>
                        <h1>Advanced Concurrency Patterns in Go</h1>
                        <div class="post-tags">
                            <span>Go</span>
                            <span>Concurrency</span>
                            <span>Patterns</span>
                        </div>
                    </header>

                    <div class="article-body">
                        <p class="lead">Go&rsquo;s concurrency primitives&mdash;goroutines and channels&mdash;are powerful, but production systems require sophisticated structures beyond the basics. This post explores advanced patterns: fan-in, fan-out, worker pools, pipelines, cancellation, and select-based coordination for improved performance, scalability, and fault tolerance.</p>

                        <h2>Fan-Out Pattern</h2>

                        <p>The fan-out pattern distributes incoming work to multiple goroutines for parallel execution on CPU-bound or I/O-bound workloads.</p>

<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
    "time"
)

func worker(id int, jobs &lt;-chan int, results chan&lt;- int, wg *sync.WaitGroup) {
    defer wg.Done()
    for j := range jobs {
        fmt.Printf("Worker %d processing job %d\n", id, j)
        time.Sleep(200 * time.Millisecond)
        results &lt;- j * 2
    }
}

func main() {
    jobs := make(chan int, 10)
    results := make(chan int, 10)
    var wg sync.WaitGroup

    // Fan-out: start multiple workers
    for w := 1; w &lt;= 3; w++ {
        wg.Add(1)
        go worker(w, jobs, results, &amp;wg)
    }

    // Send jobs
    for j := 1; j &lt;= 5; j++ {
        jobs &lt;- j
    }
    close(jobs)

    // Wait for all workers
    go func() {
        wg.Wait()
        close(results)
    }()

    // Receive results
    for r := range results {
        fmt.Println("Result:", r)
    }
}</code></pre>

                        <p>This pattern improves throughput through concurrent work but requires coordination and graceful shutdown.</p>

                        <h2>Fan-In Pattern</h2>

                        <p>The fan-in pattern merges multiple input channels into one output channel, useful for combining results from independent tasks.</p>

<pre><code class="language-go">package main

import "fmt"

func merge(cs ...&lt;-chan int) &lt;-chan int {
    out := make(chan int)
    for _, c := range cs {
        go func(ch &lt;-chan int) {
            for v := range ch {
                out &lt;- v
            }
        }(c)
    }
    return out
}

func main() {
    c1 := make(chan int)
    c2 := make(chan int)

    go func() {
        for i := 1; i &lt;= 3; i++ {
            c1 &lt;- i
        }
        close(c1)
    }()

    go func() {
        for i := 100; i &lt;= 103; i++ {
            c2 &lt;- i
        }
        close(c2)
    }()

    for v := range merge(c1, c2) {
        fmt.Println("Received:", v)
    }
}</code></pre>

                        <p>This enables parallel data sources to feed unified result streams.</p>

                        <h2>Pipeline Pattern</h2>

                        <p>The pipeline pattern connects stages via channels where each stage receives input, transforms it, and passes output to the next stage. It improves modularity, streaming efficiency, and backpressure handling.</p>

<pre><code class="language-go">package main

import "fmt"

func gen(nums ...int) &lt;-chan int {
    out := make(chan int)
    go func() {
        for _, n := range nums {
            out &lt;- n
        }
        close(out)
    }()
    return out
}

func square(in &lt;-chan int) &lt;-chan int {
    out := make(chan int)
    go func() {
        for n := range in {
            out &lt;- n * n
        }
        close(out)
    }()
    return out
}

func main() {
    for n := range square(gen(1, 2, 3, 4)) {
        fmt.Println(n)
    }
}</code></pre>

                        <p>Each stage runs concurrently, enabling efficient streaming data processing with minimal latency.</p>

                        <h2>Worker Pool Pattern</h2>

                        <p>The worker pool pattern limits concurrent goroutines to control resource usage, ideal for handling large task queues without spawning unbounded goroutines.</p>

<pre><code class="language-go">package main

import (
    "fmt"
    "time"
)

func worker(id int, jobs &lt;-chan int, results chan&lt;- int) {
    for j := range jobs {
        fmt.Printf("Worker %d started job %d\n", id, j)
        time.Sleep(300 * time.Millisecond)
        fmt.Printf("Worker %d finished job %d\n", id, j)
        results &lt;- j * 2
    }
}

func main() {
    const numWorkers = 3
    jobs := make(chan int, 5)
    results := make(chan int, 5)

    for w := 1; w &lt;= numWorkers; w++ {
        go worker(w, jobs, results)
    }

    for j := 1; j &lt;= 5; j++ {
        jobs &lt;- j
    }
    close(jobs)

    for a := 1; a &lt;= 5; a++ {
        fmt.Println("Result:", &lt;-results)
    }
}</code></pre>

                        <p>This ensures predictable concurrency, protects system resources, and improves stability under heavy load.</p>

                        <h2>Using <code>select</code> for Coordination</h2>

                        <p>The <code>select</code> statement waits on multiple channel operations simultaneously, enabling responsive and cancellable concurrency.</p>

<pre><code class="language-go">package main

import (
    "context"
    "fmt"
    "time"
)

func worker(ctx context.Context, ch chan int) {
    for {
        select {
        case val := &lt;-ch:
            fmt.Println("Processing:", val)
        case &lt;-ctx.Done():
            fmt.Println("Worker stopped.")
            return
        }
    }
}

func main() {
    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
    defer cancel()

    ch := make(chan int)
    go worker(ctx, ch)

    for i := 0; i &lt; 5; i++ {
        ch &lt;- i
        time.Sleep(400 * time.Millisecond)
    }
}</code></pre>

                        <p>This allows graceful shutdown, timeout handling, and responsive systems.</p>

                        <h2>Cancellation and Timeouts</h2>

                        <p>Go&rsquo;s <code>context</code> package controls goroutine lifetimes. Always propagate <code>context.Context</code> to enable graceful cancellation and prevent goroutine leaks.</p>

<pre><code class="language-go">ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
defer cancel()

select {
case &lt;-ctx.Done():
    fmt.Println("Timed out:", ctx.Err())
}</code></pre>

                        <h2>Best Practices for Advanced Concurrency</h2>

                        <ul>
                            <li>Prefer channels for communication, not shared memory.</li>
                            <li>Use <code>context</code> for all goroutines that can outlive their caller.</li>
                            <li>Bound concurrency with worker pools or semaphores.</li>
                            <li>Use <code>sync.WaitGroup</code> to coordinate lifecycle completion.</li>
                            <li>Combine fan-in/fan-out with pipelines for scalable data flows.</li>
                            <li>Profile and trace concurrency with <code>pprof</code> and <code>go tool trace</code>.</li>
                        </ul>

                        <h2>Conclusion</h2>

                        <p>Advanced concurrency in Go extends far beyond launching goroutines. Mastering fan-out, fan-in, worker pools, and pipelines&mdash;combined with context-based cancellation and <code>select</code> coordination&mdash;enables building efficient, responsive, resilient Go systems that scale gracefully under load.</p>
                    </div>
                </div>
                <aside class="article-sidebar">
                    <div class="sidebar-author">
                        <img src="images/pm.png" alt="Paolo Mascia" class="sidebar-author-photo">
                        <div class="sidebar-author-name">Paolo Mascia</div>
                        <div class="sidebar-author-role">AI &amp; Cloud Architect</div>
                        <p class="sidebar-author-bio">25+ years designing distributed systems. Specialized in Generative AI, LLM orchestration, and cloud-native architectures.</p>
                    </div>
                    <div class="sidebar-box">
                        <h4>More Articles</h4>
                        <a href="go-json.html" class="sidebar-link">
                            <span class="sidebar-link-tag">Go</span>
                            <div class="sidebar-link-title">Working with JSON in Go</div>
                            <span class="sidebar-link-meta">Oct 2025</span>
                        </a>
                        <a href="go-file-handling.html" class="sidebar-link">
                            <span class="sidebar-link-tag">Go</span>
                            <div class="sidebar-link-title">File Handling in Go</div>
                            <span class="sidebar-link-meta">Oct 2025</span>
                        </a>
                        <a href="go-http-server.html" class="sidebar-link">
                            <span class="sidebar-link-tag">Go</span>
                            <div class="sidebar-link-title">Creating an HTTP Server</div>
                            <span class="sidebar-link-meta">Oct 2025</span>
                        </a>
                        <a href="go-logging.html" class="sidebar-link">
                            <span class="sidebar-link-tag">Go</span>
                            <div class="sidebar-link-title">Application Logging in Go</div>
                            <span class="sidebar-link-meta">Oct 2025</span>
                        </a>
                        <a href="go-generic-data-structures.html" class="sidebar-link">
                            <span class="sidebar-link-tag">Go</span>
                            <div class="sidebar-link-title">Building Generic Data Structures in Go</div>
                            <span class="sidebar-link-meta">Oct 2025</span>
                        </a>
                    </div>
                </aside>
            </div>
        </div>
    </article>

    <footer class="footer">
        <div class="container">
            <p>&copy; 2025 Paolo Mascia. Built with curiosity and too much coffee.</p>
        </div>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-go.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>

</body>
</html>